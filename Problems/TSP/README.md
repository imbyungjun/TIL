# Traveling Salesman problem (TSP)

도시들과 도시를 이동하는데에 필요한 비용이 주어졌을때, 한 도시에서 시작해서 전체 도시를 순회한 뒤, 다시 시작점으로 되돌아오는 경로중 비용의 총 합이 최소인 경우를 찾는 문제이다.
한 도시에서 다른 도시로의 이동에 필요한 비용은 대칭적이지 않다. 즉, 도시 i에서 도시 j로의 이동 비용을 C[i][j]라고 하면 C[i][j]와 C[j][i]는 다른 값을 갖을 수 있다.
한 도시에서 특정 도시로 갈 수 없는 경우도 존재할 수 있으며 이런 경우에는 비용이 0으로 주어진다.

## 풀이
DFS 문제인줄 알았지만 경우의 수를 생각해보면 DFS로는 해결할 수 없다는것을 알 수 있다.  
DFS를 이용한 풀이를 적용하기 위해서는 첫번째 도시를 선택하고, 두번째 선택될 수 있는 도시의 경우의 수는 N-1이다. 세번째 도시의 경우의 수는 N-2가 된다. 아래에서 설명하겠지만 첫번째 도시는 어떤 도시가 선택되는지 중요하지 않으므로 전체를 탐색하는 경우의 수는 (N-1)\*(N-2)\*...\*1 = (N-1)!이 된다. 문제에서 주어진 최대 도시 개수 N은 16이므로 최대 15!이되고 이 수는 계산하면 1,307,674,368,000이 된다. TSP를 해결하기 위한 전략이 여러가지 존재한다고 하는데, 이번 문제는 Dynamic Programming을 이용하여 풀어보는 문제이다.

이 문제의 해결을 위한 첫번째 중요한 요소는 **결국엔 사이클**이라는 점이다. 즉, 최소 비용을 찾기위해서 시작점을 변경하면서 탐색을 진행하지 않아도 된다. 예를 들면,
`1 -> 2 -> 3 -> 4 -> 1`의 경로를 탐색한 이후에 `2 -> 3 -> 4-> 1 -> 2`의 경로에 대하여 최소비용을 비교하지 않아도 된다. 결국 같은 비용에 대해서 탐색하게 되기 때문이다.
```
# 아래 네가지 경우는 모두 같은 비용을 갖는다는 것을 알 수 있다.
1 -> 2 -> 3 -> 4 -> 1
2 -> 3 -> 4 -> 1 -> 2
3 -> 4 -> 1 -> 2 -> 3
4 -> 1 -> 2 -> 3 -> 4
```

최소 비용을 찾기위한 점화식은 아래 wikipedia 링크에 자세히 설명되어 있다. 이 문제도 **Working Backwards** 방식으로 풀어볼 수 있는데, 모든 도시를 순회한 이후 최종 목적지이자 시작점을 1번 도시라고 지정해보면 **최소 비용은 {2, 3, 4} 도시를 거쳐서 1번 도시로 돌아오는 경로중 가장 작은 비용**이다. 도시 i에서 j로의 이동 비용을 C[i][j]라고 표현하면 최소비용은 아래와 같이 탐색할 수 있다.
```
# set의 크기가 3인 경우
g(1, {2, 3, 4}) = min { C[1][2] + g(2, {3, 4}), C[1][3] + g(3, {2, 4}), C[1][4] + g(4, {2, 3}) }

# set의 크기가 2인 경우
g(2, {3, 4}) = min { C[2][3] + g(3, {4}), C[2][4] + g(4, {3}) }

# set의 크기가 1인 경우
g(3, {4}) = C[3][4] + g(4, null)

# set의 크기가 0인 경우
g(4, null) = C[4][1]
```

이런식으로 표현한 뒤 Dynamic Programming의 memoization을 적용하기 위해서는 **Bitmask**를 이용한다. 기본적인 DP문제들처럼 1차원 배열 혹은 2차원 배열을 이용해서는 위의 지나온 도시들을 체크한 Set을 표현할 수 없기 때문이다. Bitmask를 이용하면 Set을 쉽게 표현할 수 있다. 아래와 같은 테이블에 g(to, {visited})를 memoization한다.

| |0000|0001|0010|0011|...|1111|
|-|-|-|-|-|-|-|
|1| | | | | | |
|2| | | | | | |
|3| | | | | | |
|4| | | | | | |

## 문제 링크
[외판원 순회](https://www.acmicpc.net/problem/2098)

## 소스 코드
[TSP.py](./TSP.py)

## Reference
https://en.m.wikipedia.org/wiki/Held%E2%80%93Karp_algorithm
