# Executor
Executor는 Java 5 부터 지원된 Task를 실행하는 가장 좋은 방법 중 하나이다. Executor의 다양한 종류의 실행 정책과 스레드 풀 관리는 비동기 작업 실행에 유용하다. Executor는 작업의 등록과 작업의 실행을 분리하는 표준적인 방법이며, 작업은 Runnable의 구현체로 정의된다.  

Executor의 구조는 프로듀서-컨슈머 패턴에 기반하고 있으며, 작업을 생성해 등록하는 클래스가 프로듀서가 되고, 작업을 실제로 수행하는 스레드가 컨슈머가 된다.

작업별로 스레드를 생성하는 전략(thread-per-task)에서 풀을 기반으로 하는 전략(pool-based)으로 변경하면 안정성 측면에서 장점이 있다. 큰 부하가 발생하더라도 OutOfMemoryError가 발생하지 않는다는 점이다. 게다가 부하에 따라 수천 개의 스레드를 생성해 제한된 양의 CPU와 메모리 자원을 서로 사용하고자하는 경쟁상황에 빠지지 않도록 하기 때문에 성능이 떨어질 때도 점진적으로 떨어진다.

## 실행 정책
작업을 등록하는 부분과 실행하는 부분을 분리할 경우, 실행 정책을 유연하게 변경할 수 있다는 장점이 있다. Executor의 실행 정책은 다음과 같은 정책들을 설정할 수 있다.
* 작업을 어느 스레드에서 실행할 것인가?
* 작업을 어떤 순서로 실행할 것인가? (FIFO, LIFO, 등...)
* 동시에 몇 개의 작업을 병렬로 실행할 것인가?
* 최대 몇 개까지의 작업이 큐에서 실행을 대기할 수 있게 할 것인가?
* 시스템에 부하가 많이 걸려서 작업을 거절해야 하는 경우, 어떤 작업을 버릴 것이며, 어떻게 알릴 것인가?
* 작업을 실행하기 직전이나 실행한 직후에 어떤 동작을 수행할 것인가?

## 스레드 풀
스레드 풀은 미리 만들어 놓은 스레드를 풀의 형태로 관리한다. 스레드 풀은 자신이 미리 만들어 놓은 스레드를 이용해서 처리할 작업을 쌓아둬야 하기 때문에 작업 큐(work queue)와 밀접한 관련이 있다. 작업 스레드는 단순히 작업 큐에서 실행할 다음 작업을 가져오고, 작업을 실행하고, 실행할 다음 작업이 나타날 때까지 대기하는 일을 반복한다.

스레드 풀을 이용하면 계속해서 새로운 스레드를 생성할 필요가 없기 때문에 자원 소모가 적어지고, 작업을 가져오는 시점에 이미 스레드가 만들어져 있으므로 프로그램의 전반적인 반응속도가 향상된다.

자바 클래스 라이브러리의 Executors 클래스에서는 아래와 같은 미리 정의된 스레드 풀을 제공한다.

* **newFixedThreadPool:** 처리할 작업이 등록되면 그에 따라 실제 작업할 스레드를 하나씩 생성한다. 생성할 수 있는 스레드의 최대 개수는 제한되어 있으며 제한된 개수까지 스레드를 생성하고 나면 더 이상 생성하지 않고 스레드 수를 유지한다.
* **newCachedThreadPool:** 캐시 스레드 풀은 현재 풀에 갖고 있는 스레드의 수가 처리할 작업의 수보다 많아서 쉬는 스레드가 많이 발생할 때 쉬는 스레드를 종료시켜 훨씬 유욘하게 대응할 수 있으며, 처리할 작업의 수가 많아지면 필요한 만큼 스레드를 새로 생성한다. 반면에 스레드의 수에는 제한을 두지 않는다.
* **newSingleThreadExecutor:** 단일 스레드로 동작하는 Executor로서 작업을 처리하는 스레드가 하나뿐이다. 작업 처리중에 Exception이 발생하여 비정상적으로 종료되면 새로운 스레드를 생성하여 나머지 작업을 실행한다. 등록된 작업은 설정된 작업 큐에서 지정한 순서에 따라 반드시 순차적으로 처리된다.
* **newScheduledThreadPool:** 일정 시간 이후에 실행하거나 주기적으로 작업을 실행할 수 있으며, 스레드의 수가 고정되어 있는 형태의 Executor.Timer 클래스의 기능과 유사하다. 

> 스레드 풀은 작업의 처리가 완료되어도 스레드를 소멸시키지 않는다. 한 번 생성된 스레드는 계속해서 재사용을 위해 스레드 풀에서 관리된다.

## Executor 동작 주기
Executor는 작업을 별도의 스레드에서 수행시킨다. JVM은 모든 스레드가 종료되기 전에는 종료하지 않고 대기하기 때문에 Executor를 제대로 종료시키지 않으면 JVM 자체가 종료되지 않고 대기하기도 한다.

Executor는 작업을 비동기적으로 실행하기 때문에 특정 시점에 작업의 상태를 파악하기 어렵다. 어떤 작업은 이미 완료됐을 수 있고, 몇 개의 작업은 아직 실행 중일 수 있고, 또 다른 작업은 아직 큐에서 대기하고 있을 수 있다. 이런 작업을 실행하는 동작 주기와 관련해 Executor를 상속받은 ExecutorService 인터페이스에는 동작 주기를 관리할 수 있는 여러가지 메서드가 추가되어 있다.
```java
public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    ...
}
```

`shutdown()` 메서드를 실행하면 종료중 상태로 들어간다. 이 상태에서는 새로운 작업을 등록받지 않으며, 이전에 등록된 작업까지는 모두 끝마칠 수 있다.  
`shutdownNow()` 메서드를 실행하면 강제 종료 절차를 진행하여 현재 진행중이던 작업도 가능한 한 취소시키고, 대기 중이던 작업은 실행시키지 않는다.

## 지연 작업, 주기적 작업

