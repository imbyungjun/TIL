# Observer Pattern

## 의도
객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 벼낳ㄹ 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만든다.

## 동기
하나의 시스템을 서로 연동되는 다수의 클래스로 분할할 때 발생하는 공통적인 부작용은 관련된 객체 간에 일관성을 유지하도록 해야 한다는 것이다. 그렇다고해서 일관성 관리를 위해서 객체 간의 결합도를 높이고 싶지는 않다. 각 클래스의 재사용성이 떨어지기 때문에.
예를 들어, GUI 툴킷은 표현 부분과 이에 대응하는 데이터를 분리한다. 테이블 형태의 객체와 바 형태의 객체 모두 동일한 자료 값을 나타낸다면, 테이블과 바의 표현은 독립적으로 재사용이 가능해야 한다. 테이블과 바는 데이터 객체에 종속적이기 때문에 그 데이터에 일어난 변경을 통보받아야한다. 서로 다른 다수의 사용자 인터페이스가 하나의 데이터에 종속될 수 있다.  
감시자 패턴은 이런 관련성을 관리한다. 이 패턴에서 중요한 객체는 **주체**(Subject)와 **감시자**(Observer)이다. 주체는 독립된 여러 개의 감시가 있을 수 있다. 모든 감시자는 주체의 상태 변화가 있을 때마다 이 변화를 통보받는다. 각 감시자는 주체의 상태와 자신의 상태를 동기화시키기 위해서 주체의 상태를 알아본다.  
This kind of interaction is called **Publish-Subscribe** relation. 주체는 상태 변경에 대한 통보를 하는 것이므로 누가 감시자인지 모른 채 통보를 발송한다. 불특정 다수의 감시자가 이 통보를 수신하기 위해서 구독을 신청한다.

## 활용성
감시자 패턴을 사용하는 상황

* 어떤 추상 개념이 두 가지 양상을 갖고 하나가 다른 하나에 종속적일 때. 각 양상을 별도의 객체로 캡슐화하여 이들 가각을 재사용할 수 있다.
* 한 객체에 가해진 변경으로 다른 객체를 변경해야 하고, 프로그래머들은 얼마나 많은 객체들이 변경되어야 하는지 몰라도 될 때.
* 어떤 객체가 다른 객체에 자신의 변화를 통보할 수 있는데, 그 변화에 관심있어 하는 객체들이 누구인지에 대한 가정 없이도 그러한 통보가 될 때.

## 참여자
* **Subject**  
감시자들을 알고 있는 주체. 임의 개수의 감시자 객체는 주체를 감시할 수 있다. 주체는 감시자 객체를 붙이거나 떼는 데 필요한 인터페이스를 제공한다.
* **Observer**  
주체에 생긴 변화에 관심 있는 객체를 갱신하는 데 필요한 인터페이스를 정의한다. 이로써 주체의 변경에 따라 변화되어야 하는 객체들의 일관성을 유지한다.
* **ConcreteSubject**    
ConcreteObserver 객체에게 알려주어야 하는 상태를 저장한다. 이 상태가 변경될 때 감시자에게 변경을 통보한다.
* **ConcreteObserver**  
ConcreteSubject 객체에 대한 참조자를 관리한다. 주체의 상태와 일관성을 유지해야 하는 상태를 저장한다. 주체의 상태와 감시자의 상태를 일관되게 유지하는 데 사용하는 갱신 인터페이스를 구현한다.

## 협력 방법
* **ConcreteSubject**는 Observer의 상태와 자신의 상태가 달라지는 변경이 발생할 때마다 감시자에게 통보한다.  
* ConcreteSubject에서 변경이 통보된 후, **ConcreteObserver**는 필요한 정보를 주체에게 질의하여 얻어온다. **ConcreteObserver**는 이 정보를 이용해서 주체의 상태와 자신의 상태를 일치시킨다.  
