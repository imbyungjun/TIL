# Command Pattern

## 의도
요청 자체를 캡슐화하는 것이다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산을 지원한다.

## 다른 이름
작동(Action), 트랜잭션(Transaction)

## 동기
항상 그렇지는 않지만, 요청받은 연산이 무엇이며, 이를 처리할 객체가 누구인지에 대한 아무런 정보 없이 임의의 객체에 메세지를 보내야 할 때가 있다. 예를 들어, 사용자 인터페이스 툴킷은 버튼, 메뉴 같은 객체를 포함하는데, 이는 사용자의 메세지를 처리하게 된다. 그러나 사용자 인터페이스 툴킷은 버튼과 메뉴에서 요청을 처리할 수 없다. 툴킷을 사용하는 응용프로그램만이 어떤 객체를 통해서 어떤 일이 되어야 하는지 알기 때문이다. 사용자 인터페이스 툴킷 설계자의 입장에서는 어떤 객체가 이 요청을 처리할지를 알아낼 방법이 없다.

명령 패턴은 툴킷 객체가 요청 자체를 객체로 바꿈으로써 명시되지 않은 응용프로그램 객체의 요청을 처리할 수 있도록 지원하는 패턴이다. 이 객체는 다른 객체처럼 저장되거나 전달될 수도 있다. 이 패턴의 핵심은 연산을 실행하는 데 필요한 인터페이스를 언언해 놓는 Command 추상 클래스이다. 이 클래스에 들어가는 가장 기본적인 연산이 execute()이다. Command 추상 클래스에서 상속받은 Command 서브클래스들은 수신 객체에 대한 참조자를 인스턴스 변수로 저장하며, 이 수신 객체에 정의된 요청을 호출하도록 execute()를 구현하여 수신자-작동(receiver-action)쌍을 정의한다. 수신 객체는 자신에게 전달된 요청을 어떻게 처리햐야 하는지 알고있다.

이 Command 객체로 쉽게 구현할 수 있는 대표적인 예로 메뉴가 있다. 메뉴에서 각 선택 항목은 MenuItem 클래스의 한 인스턴스이다. 응용프로그램을 나타내는 Application 클래스는 이들 메뉴를 생성하고 메뉴 항목을 관리한다. 또한, 사용자가 open한 Document 객체가 무엇인지 계속 추적한다.

응용프로그램은 각 MenuItem 객체를 Command의 어떤 서브클래스 인스턴스와 연결되도록 설정한다. 사용자가 MenuItem 인스턴스를 선택하면 MenuItem 인스턴스는 연결된 Command 서브클래스의 execute()연산을 호출한다. 

## 활용성
* 수행할 동작을 객체로 매개변수화하고자 할 때. 절차지향 프로그램에서는 이를 콜백(callback) 함수를 사용해서 이러한 매개변수화를 표현할 수 있다. Command 패턴은 콜백을 객체지향방식으로 나타낸 것이다.
* 서로 다른 시간에 요청을 명시하고, 저장하며, 실행하고 싶을 때. Command 객체는 원래의 요청과 다른 생명주기(lifetime)가 있다. 요청을 받아 처리하는 객체가 주소 지정 방식과는 독립적으로 표현될 수 있다면, Command 객체를 다른 프로세스에게 넘겨주고 거기서 해당 처리를 진행하게 할 수 있다.
* 실행 취소 기능을 지원하고 싶을 때. Command의 Execute() 연산은 상태를 저장할 수 있는데, 이를 이용해서 지금까지 얻은 결과를 바꿀 수 있다. 이를 위해 Unexecute() 연산을 Command 클래스의 인터페이스에 추가한다. 실행된 명령어를 모두 기록해 두었다가 이 리스트를 역으로 탐색해서 다시 Unexecute()를 수행하게 한다. Execute()와 Unexecute() 연산의 반복 사용을 통해 수행과 취소를 무한 반복할 수 있다.
* 기본적인 연산의 조합으로 만든 상위 수준 연산을 써서 시스템을 구조화하고 싶을 때. 정보 시스템의 일반적인 특성은 트랜잭션(transaction)을 처리해야 한다는 것이다. 트랜잭션은 일련의 과정을 통해 데이터를 변경하는 것. Command 클래스는 일관된 인터페이스를 정의하는데, 이로써 모든 트랜잭션이 동일한 방식으로 호출된다. 새로운 트랜잭션을 만들면 상속으로 Command 클래스를 확장하면 되므로 시스템 확장도 어렵지 않다.
