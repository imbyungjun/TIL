# Command Pattern

## 의도
요청 자체를 캡슐화하는 것이다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산을 지원한다.

## 다른 이름
작동(Action), 트랜잭션(Transaction)

## 동기
항상 그렇지는 않지만, 요청받은 연산이 무엇이며, 이를 처리할 객체가 누구인지에 대한 아무런 정보 없이 임의의 객체에 메세지를 보내야 할 때가 있다. 예를 들어, 사용자 인터페이스 툴킷은 버튼, 메뉴 같은 객체를 포함하는데, 이는 사용자의 메세지를 처리하게 된다. 그러나 사용자 인터페이스 툴킷은 버튼과 메뉴에서 요청을 처리할 수 없다. 툴킷을 사용하는 응용프로그램만이 어떤 객체를 통해서 어떤 일이 되어야 하는지 알기 때문이다. 사용자 인터페이스 툴킷 설계자의 입장에서는 어떤 객체가 이 요청을 처리할지를 알아낼 방법이 없다.

명령 패턴은 툴킷 객체가 요청 자체를 객체로 바꿈으로써 명시되지 않은 응용프로그램 객체의 요청을 처리할 수 있도록 지원하는 패턴이다. 이 객체는 다른 객체처럼 저장되거나 전달될 수도 있다. 이 패턴의 핵심은 연산을 실행하는 데 필요한 인터페이스를 언언해 놓는 Command 추상 클래스이다. 이 클래스에 들어가는 가장 기본적인 연산이 execute()이다. Command 추상 클래스에서 상속받은 Command 서브클래스들은 수신 객체에 대한 참조자를 인스턴스 변수로 저장하며, 이 수신 객체에 정의된 요청을 호출하도록 execute()를 구현하여 수신자-작동(receiver-action)쌍을 정의한다. 수신 객체는 자신에게 전달된 요청을 어떻게 처리햐야 하는지 알고있다.

이 Command 객체로 쉽게 구현할 수 있는 대표적인 예로 메뉴가 있다. 메뉴에서 각 선택 항목은 MenuItem 클래스의 한 인스턴스이다. 응용프로그램을 나타내는 Application 클래스는 이들 메뉴를 생성하고 메뉴 항목을 관리한다. 또한, 사용자가 open한 Document 객체가 무엇인지 계속 추적한다.

응용프로그램은 각 MenuItem 객체를 Command의 어떤 서브클래스 인스턴스와 연결되도록 설정한다. 사용자가 MenuItem 인스턴스를 선택하면 MenuItem 인스턴스는 연결된 Command 서브클래스의 execute()연산을 호출한다. 
